# Bunin Every Dat bot

## Описание проекта
Данный репозиторий –– бот в телеграме, который подбирает строчку Бунина, рифмующуюся со строчкой пользователя. У него также есть несколько дополнительных функций

- изменение списка частей речи, на которые можно рифмовать (например, если убрать "глагол" из этого списка, бот не будет выдавать пользователю строчки Бунина, оканчивающиеся глаголом)
- функция подбора другой рифмы по тому же запросу
- статистика по пользователям
- проверка строки пользователя на сходство со строчками Бунина (на основе ML)

Бота можно найти по [ссылке](https://t.me/BuninEveryDayBot) или по тегу **@BuninEveryDayBot**.

Если что-то пойдет не так, нажмине в боте команду \start (перезапуск бота) или \menu (аналог \help с информацией о боте и возврат в главное меню).

Бот работает в автономном режиме, потому что выложен на [Амвера](https://cloud.amvera.ru) по домену **amvera-mayyagore-run-bot-bunineveryday---proekt-2024**. Амвера - аналог Heroku, выбран, потому что pythonanywhere не хватило памяти для библиотек.

   
## Структура репозитория
- **bot.py** –– файл с основным кодом

- **rhymes.py** –– файл с кодом, который подбирает рифму к слову  

- **classifier.py** –– файл с кодом обучения модели

- **lines.csv** –– файл со строчками Бунина, с ним бот работает при подборе рифмы (для df)

- **plot.png** –– график, отображающий статистику того, сколько раз каждый пользователь попросил предоставить другую рифму на каждом запросе (1 линия - 1 пользователь)

- **parcing** –– папка с кодом, который краулерит строчки Бунина и других поэтов, и результатами этого кода
    - **pages.txt** и **links2.txt** –– промежуточные файлы, используемые при краулинге, чтобы не потерять результат

    - **parce_lines_2.py** –– файл, который краулерит строчки Бунина. Его можно не запускать - его результат уже есть в файле lines.csv в основной директории

    - **random_poems.csv**  –– файл, на котором обучается модель со строчками случайных поэтов. Строчек примерно столько же, сколько строчек Бунина
      
    - **bunin_poems.csv**  –– файл, на котором обучается модель со строчками бунина (просто отформатированная версия lines.csv). Получилось больше данных, чем в итоге использовала для обучения...


## Установка

Для корректной работы необходимо установить следующие модули:

```bash
pip install telebot
pip install pyTelegramBotAPI
pip install matplotlib
pip install requests
pip install fake_useragent
pip install pandas
pip install pymorphy2
pip install beautifulsoup4
pip install scikit-learn
pip install nltk
```
Если вы перезапустили код бота в пайчарме, то, пожалуйста, не нажимайте на кнопки, которые бот выдал при предыдущих сессиях - это его уронит.

## Описание принципа работы

### Подбор рифмы:
1. С [сайта](https://www.culture.ru/literature/poems/author-ivan-bunin) были скраулерены все тексты Бунина, и разбиты на строчки. Затем для каждой строчки было определено последнее слово и его часть речи. Весь этот код и его результаты находятся в папке parcing.
2. После получения запроса от пользователя бот проверяет, написано ли последнее слово кириллицей. После этого краулерит рифмы к последнему слову запроса с [сайта](https://rifme.net/) (как точные рифмы, так и неточные, в разных падежах и числах). Для каждого полученного слова бот проверяет, нет ли строчки, заканчивающейся таким словом в датафрейме со строчками Бунина. Получается датафрейм с рифмующимися строчками.
3. Бот выдает пользователю одну строчку, затем по кнопке продолжает выдавать строчки из датафрейма с рифмами до нажатия кнопки "Взять эту рифму" (или пока строчки не кончатся). Или бот выдает сообщение о том, что рифм не нашел 

### Проверка строчки на сходство со строчкой Бунина:
1. Как и для подбора рифмы, были получены строчки Бунина и столько же строчек случайных поэтов
2. На получившихся датафреймах была обучена линейная регрессия (TF IDF векторайзер). Модель обучалась на строчках, а не на текстах стихотворений, потому что то, как Бунин делит предложения на строчки и какой они длины, - тоже признак Бунина. Метрики удручающие - около 63%, но я перепробовала все комбинации классификаторов и векторайзеров, и это был лучший.
3. При получении запроса от пользователя бот классифицирует его строчку с помощью линейной регрессии и выдает результат "Похоже" / "Не похоже"

### Общие принципы:
- Информация по юзерам (в т.ч. список допустимых частей речи и информация для статистики) хранится в словаре
- В боте используются состояния: бот начинает работу в состоянии start (чтобы он не сломался от пустого словаря с юзерами), работает в меню и с кнопками изменения допустимых частей речи в состоянии main, рифмует сообщения пользователя в состояниях rhyme, отдает строчку модели в состоянии model.
- Пользователь может сказать боту подобрать другую рифму, если выданная ему не понравилась. Для этого используются коллбэки. Они же используются для инлайн кнопок в меню и инлайн кнопок с изменяемым текстом в разделе с частями речи.
- С помощью коллбэков бот умеет исправлять свои сообщения: переписка не засорена. С помощью исправляения сообщений также избегается наложение двух поисков рифмы одновременно - инлайн кнопки на первом ответе на запрос пропадают.
